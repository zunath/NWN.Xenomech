#define SHADER_TYPE 2

const int TELEGRAPH_SHAPE_NONE = 0;
const int TELEGRAPH_SHAPE_SPHERE = 1;
const int TELEGRAPH_SHAPE_CONE = 2;
const int TELEGRAPH_SHAPE_LINE = 3;

#include "inc_target"
#include "inc_postpr"
#include "inc_scriptable"

float CalculateLineFraction(vec2 origin, float rotation, float lineLength, vec2 point)
{
    float rads = radians(rotation + 90.0);
    vec2 direction = vec2(cos(rads), sin(rads));
    vec2 originToPoint = point - origin;
    vec2 projectedPoint = origin + direction * dot(originToPoint, direction);
    return length(projectedPoint - origin) / lineLength;
}

vec2 Rotate(vec2 pos, float angle)
{ 
    float radian = radians(-angle);
    float s = sin(radian);
    float c = cos(radian);
    return vec2(c * pos.x - s * pos.y, s * pos.x + c * pos.y);
}

float GetThrobStrength(float base, float speed)
{
    return base + (1.0 + sin(float(worldtimerTimeOfDay) / speed)) * 0.5 * (1.0 - base);
}

float CalculateTelegraphColour(vec3 pixelPos, int shapeType, vec4 data1, vec4 data2)
{
    const float borderWidth = 0.025;
    const float strengthEmpty = 0.25;
    const float strengthFull = 0.75;
    const float strengthBorder = strengthFull;
    float strengthThrob = GetThrobStrength(strengthBorder, 300.0);

    int currentTime = scriptableInt16;

    vec3 origin = data1.xyz;
    float rotation = data1.w;  
    float startTime = data2.x;
    float endTime = data2.y;
    float sizeX = data2.z;
    float sizeY = data2.w;

    float interp = min(1.0, (currentTime - startTime) / (endTime - startTime));  
    float sizeXCurrent = mix(0.0, sizeX, interp); 
    float sizeYCurrent = mix(0.0, sizeY, interp);

    vec3 originToPixel = pixelPos - origin;
    float originToPixelDist = length(originToPixel);

    float strength = 0.0;

    if (shapeType == TELEGRAPH_SHAPE_SPHERE)
    {   
        float distToSphere = originToPixelDist;
        float outerStrength = distToSphere > sizeX ? 0.0 : strengthEmpty;
        float outerBorderStrength = distToSphere > sizeX || distToSphere < sizeX - borderWidth ? 0.0 : strengthThrob;
        float innerStrength = distToSphere > sizeXCurrent ? 0.0 : strengthFull;
        strength = max(outerStrength, max(outerBorderStrength, innerStrength));
    }
    else if (shapeType == TELEGRAPH_SHAPE_CONE)
    {
        const float sin30Degrees = 0.50000019433;
        const float cos30Degrees = 0.86602529158;
        float distToCone = distanceToCone(vec3(Rotate(originToPixel.xy, rotation+90.0), originToPixel.z), vec2(sin30Degrees, cos30Degrees), sizeX);
        float distStrength = CalculateLineFraction(origin.xy, rotation+90.0, sizeX, pixelPos.xy) >= interp ? strengthEmpty : strengthFull;
        strength = distToCone > 0.0 ? 0.0 : (distToCone > -borderWidth ? strengthThrob : distStrength);
    }
    else if (shapeType == TELEGRAPH_SHAPE_LINE)
	{
		vec2 direction = vec2(cos(radians(rotation)), sin(radians(rotation))); // Ensure correct facing
		vec2 startPos = origin.xy; 
		vec2 endPos = startPos + direction * sizeX; // Extend the line from origin

		// Project point onto the line
		vec2 originToPixel = pixelPos.xy - startPos;
		float projection = dot(originToPixel, direction);
		vec2 projectedPoint = startPos + direction * projection;

		float distAlongLine = projection;
		float distFromCenter = length(pixelPos.xy - projectedPoint);

		float withinLength = (distAlongLine >= 0.0 && distAlongLine <= sizeX) ? 1.0 : 0.0;
		float withinWidth = (distFromCenter <= sizeY * 0.5) ? 1.0 : 0.0;
		float borderEffect = (distFromCenter > sizeY * 0.5 - borderWidth) ? strengthThrob : strengthFull;

		strength = withinLength * withinWidth * borderEffect;
	}

    return strength;
}

float CalculateTelegraphStrengthTotal(vec3 pixelPos)
{
    float strength = 0.0;
    strength = max(strength, CalculateTelegraphColour(pixelPos, scriptableInt1, scriptableVec1, scriptableVec2));
    strength = max(strength, CalculateTelegraphColour(pixelPos, scriptableInt2, scriptableVec3, scriptableVec4));
    strength = max(strength, CalculateTelegraphColour(pixelPos, scriptableInt3, scriptableVec5, scriptableVec6));
    strength = max(strength, CalculateTelegraphColour(pixelPos, scriptableInt4, scriptableVec7, scriptableVec8));
    strength = max(strength, CalculateTelegraphColour(pixelPos, scriptableInt5, scriptableVec9, scriptableVec10));
    strength = max(strength, CalculateTelegraphColour(pixelPos, scriptableInt6, scriptableVec11, scriptableVec12));
    strength = max(strength, CalculateTelegraphColour(pixelPos, scriptableInt7, scriptableVec13, scriptableVec14));
    strength = max(strength, CalculateTelegraphColour(pixelPos, scriptableInt8, scriptableVec15, scriptableVec16));
    return strength;
}

void main()
{
    vec3 pixelPos = (m_view_inv * vec4(GetViewPositionFromDepth(vVertexTexCoords, GetDepth(vVertexTexCoords)), 1.0)).xyz;
    float telegraphStrength = CalculateTelegraphStrengthTotal(pixelPos);
    gl_FragColor = FS_PostProcess();
    gl_FragColor.r = mix(gl_FragColor.r, 1.0, telegraphStrength);
}
